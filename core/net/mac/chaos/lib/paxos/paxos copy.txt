/*******************************************************************************
 * BSD 3-Clause License
 *
 * Copyright (c) 2017 Beshr Al Nahas, Valentin Poirot and Olaf Landsiedel.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
/*
 * \file
 *         Paxos library
 * \author
 *         Beshr Al Nahas <beshr@chalmers.se>
 *         Valentin Poirot <poirotv@chalmers.se>
 *         Olaf Landsiedel <olafl@chalmers.se>
 */

#include "contiki.h"
#include <string.h>

#include "chaos.h"
#include "chaos-random-generator.h"
#include "node.h"
#include "paxos.h"
#include "chaos-config.h"

#undef ENABLE_COOJA_DEBUG
#define ENABLE_COOJA_DEBUG COOJA
#include "dev/cooja-debug.h"


#ifndef COMMIT_THRESHOLD
#define COMMIT_THRESHOLD 6
#endif

// TODO: remove?
#ifndef N_TX_COMPLETE
#define N_TX_COMPLETE 9
#endif

#ifndef CHAOS_RESTART_MIN
#define CHAOS_RESTART_MIN 6
#endif

#ifndef CHAOS_RESTART_MAX
#define CHAOS_RESTART_MAX 10
#endif

#define LIMIT_TX_NO_DELTA 0

#define FLAGS_LEN_X(X)   (((X) >> 3) + (((X) & 7) ? 1 : 0))
#define FLAGS_LEN   (FLAGS_LEN_X(chaos_node_count))
//#define LAST_FLAGS  ((1 << (((chaos_node_count - 1) % 8) + 1)) - 1)
#define LAST_FLAGS  ((1 << (((chaos_node_count - 1) & 7) + 1)) - 1)
//#define FLAG_SUM    (((FLAGS_LEN - 1) * 0xFF) + LAST_FLAGS)
#define FLAG_SUM    (((FLAGS_LEN - 1) << 8) - (FLAGS_LEN - 1) + LAST_FLAGS)

#if NETSTACK_CONF_WITH_CHAOS_NODE_DYNAMIC
#define FLAGS_ESTIMATE FLAGS_LEN_X(MAX_NODE_COUNT)
#warning "APP: due to packet size limitation: maximum network size = MAX_NODE_COUNT"
#else
#define FLAGS_ESTIMATE FLAGS_LEN_X(CHAOS_NODES)
#endif

//#if (CHAOS_APP_PAYLOAD_LEN-FLAGS_ESTIMATE-4) > 0
//#define APP_DUMMY_LEN MIN(CHAOS_APP_PAYLOAD_LEN-FLAGS_ESTIMATE-sizeof(uint32_t), CHAOS_MAX_PAYLOAD_LEN-FLAGS_ESTIMATE-sizeof(uint32_t))
//#else
//#define APP_DUMMY_LEN 0
//#endif

typedef struct __attribute__((packed)) paxos_t_local_struct {
  paxos_t paxos;
  uint8_t flags[FLAGS_ESTIMATE];
} paxos_t_local;

static int tx = 0;
static int complete = 0;
static uint16_t completion_slot, off_slot;
static int tx_count_complete = 0;
static int invalid_rx_count = 0;
static int got_valid_rx = 0;
static unsigned short restart_threshold;
static paxos_t_local paxos_local; /* used only for house keeping and reporting */
static paxos_state_t paxos_state; /* current transaction state */
static uint8_t* paxos_flags;

static uint8_t bit_count(uint8_t u)
{
  return  (u -(u>>1)-(u>>2)-(u>>3)-(u>>4)-(u>>5)-(u>>6)-(u>>7));
}

/*
 * Assumptions:
 * 1. All the nodes can receive the content of a broadcast primitive. (even Proposers)
 * 2. Every Proposer is an acceptor.
 * 2.a. The Acceptor logic is done before the Proposer logic.
 * 3. We locally keep the rx packet data with the highest ballot N received so far (Optimization)
 * 3.a. Upon reception of a ballot n < N, we discard it and retransmit N
 * 4. A Proposer learning that there is a higher ballot around competes directly.
 */

/* TODO:
 * 1. split proposer and acceptor states
 * 2. Do acceptor logic on proposer after sending to make sure we update our acceptor part state as soon as others receive our msg
 */
static chaos_state_t
process(uint16_t round_count, uint16_t slot_count, chaos_state_t current_state, int chaos_txrx_success, size_t payload_length, uint8_t* rx_payload, uint8_t* tx_payload, uint8_t** app_flags)
{
  paxos_t* tx_paxos = (paxos_t*) tx_payload;
  paxos_t* rx_paxos = (paxos_t*) rx_payload;
  paxos_t* payload = rx_paxos;
  if(current_state == CHAOS_TX){
    payload = tx_paxos;
  }
  uint8_t rx_delta = 0;

  if (chaos_txrx_success
      && (current_state == CHAOS_RX
          || (current_state == CHAOS_TX && paxos_state.proposer.is_proposer)) ) { /* RX a valid packet */

    got_valid_rx = 1;

    //copy everything except flags
    //memcpy(tx_paxos, rx_paxos, sizeof(paxos_t));

    if ( /* rx_paxos->ballot.n == 0 ||*/payload->phase == PAXOS_INIT) { //no proposals, just a heart beat from initiator
      if (paxos_state.proposer.is_proposer) {
        if(paxos_state.proposer.phase == PAXOS_INIT){
          paxos_state.proposer.phase = PAXOS_PREPARE;
          tx_paxos->ballot.n = paxos_state.proposer.proposed_ballot.n;
          tx_paxos->phase = PAXOS_PREPARE;
          paxos_state.acceptor.min_proposal.n = paxos_state.proposer.proposed_ballot.n;
        }
        //paxos_state.rx_accepted_proposal.n 
        //tx_paxos->flags has only my flag set. No need to do anything
        tx = 1;
      } else {
        memcpy(tx_paxos, payload, sizeof(paxos_t));
        //set chaos progress flags
        //merge flags and do tx decision based on flags
        tx = 0;
        uint16_t flag_sum = 0;
        int i;
        for (i = 0; i < FLAGS_LEN; i++) {
          COOJA_DEBUG_STR("f");
          tx |= (rx_paxos->flags[i] != tx_paxos->flags[i]);
          tx_paxos->flags[i] |= rx_paxos->flags[i];
          flag_sum += tx_paxos->flags[i];
        }
        if (flag_sum >= FLAG_SUM) {
          complete = 1;
        }
      }
      rx_delta = tx;
    } else {
      /* do acceptor logic */
      //if (payload->ballot.n >= tx_paxos->ballot.n && payload->phase >= tx_paxos->phase) { /* reply to higher ballots and higher phase only */
      if (payload->ballot.n > tx_paxos->ballot.n || (payload->ballot.n == tx_paxos->ballot.n && payload->phase >= tx_paxos->phase)) { /* reply to higher ballots or same ballot with higher phase ==> newer packets */

        /*if(payload != tx_paxos){ 
          memcpy(tx_paxos, rx_paxos, sizeof(paxos_t));
        }*/

        if (!(payload->ballot.n == tx_paxos->ballot.n && payload->phase == tx_paxos->phase)) {
          memcpy(tx_paxos, rx_paxos, sizeof(paxos_t));
        }

        if (payload->phase == PAXOS_PREPARE) {
          //received higher proposal
          if (payload->ballot.n > paxos_state.acceptor.min_proposal.n) {
            paxos_state.acceptor.min_proposal.n = payload->ballot.n;
          }
          /* report the maximum accepted proposal and corresponding value */
          if (payload->proposal.n < paxos_state.rx_accepted_proposal.n) {
            tx_paxos->proposal.n = paxos_state.rx_accepted_proposal.n;
            tx_paxos->value = paxos_state.rx_accepted_value;
            tx = 1; //signal change
          } else { //update local cash of heard proposal to speed up convergence
            paxos_state.rx_accepted_proposal.n = payload->proposal.n;
            paxos_state.rx_accepted_value = payload->value;
          }
        } else if (payload->phase == PAXOS_ACCEPT) {
          if (payload->ballot.n >= paxos_state.acceptor.min_proposal.n) {
            //do accept
            paxos_state.acceptor.accepted_proposal.n = paxos_state.acceptor.min_proposal.n =
                payload->ballot.n;
            paxos_state.acceptor.accepted_value = payload->value;
          }

          //update rx_min_proposal
          paxos_state.rx_min_proposal.n = MAX(paxos_state.acceptor.min_proposal.n,
              paxos_state.rx_min_proposal.n);
          paxos_state.rx_min_proposal.n = MAX(payload->proposal.n,
              paxos_state.rx_min_proposal.n);

          if (tx_paxos->proposal.n != paxos_state.rx_min_proposal.n) {
            tx_paxos->proposal.n = paxos_state.rx_min_proposal.n; //put the max in
            tx = 1;
          }

          //update rx_accepted_proposal with maximum accepted or heard so far
          if (paxos_state.acceptor.accepted_proposal.n
              > paxos_state.rx_accepted_proposal.n) {
            paxos_state.rx_accepted_proposal.n = paxos_state.acceptor.accepted_proposal.n;
            paxos_state.rx_accepted_value = paxos_state.acceptor.accepted_value;
          }

        } else {
          /* ERROR! */
        }
        //COOJA_DEBUG_STR("");
        //COOJA_DEBUG_PRINTF("");

        //merge flags only if same ballot and same phase, otherwise, adopt newer
        tx = 0;
        uint16_t flag_sum = 0;
        int i;
        if (payload->ballot.n == tx_paxos->ballot.n && payload->phase == tx_paxos->phase){
          // This condition is never met

          //set chaos progress flags
          //merge flags and do tx decision based on flags
          for (i = 0; i < FLAGS_LEN; i++) {
            COOJA_DEBUG_STR("f");
            tx |= (payload->flags[i] != tx_paxos->flags[i]);
            tx_paxos->flags[i] |= payload->flags[i];
            flag_sum += tx_paxos->flags[i];
          }
        } else if (payload->ballot.n > tx_paxos->ballot.n || payload->phase > tx_paxos->phase){


          for (i = 0; i < FLAGS_LEN; i++) {
            COOJA_DEBUG_STR("f");
            tx_paxos->flags[i] = payload->flags[i];
            flag_sum += tx_paxos->flags[i];
          }
          /* set my flag */
          unsigned int array_index = chaos_node_index / 8;
          unsigned int array_offset = chaos_node_index % 8;
          tx_paxos->flags[array_index] |= 1 << (array_offset);
          tx = 1;
        }

        rx_delta = tx;
        if(payload->phase == PAXOS_ACCEPT && flag_sum >= FLAG_SUM){
          if(!complete && !paxos_state.proposer.got_majority){ //store when we reach completion
            completion_slot = slot_count;
            complete = 1;
          }
        }

      } else {
        //teach the higher ballot to the guys who sent the lower ballot
        rx_delta = 1;
      }

      /* do proposer logic unless we won already */
      if (paxos_state.proposer.is_proposer && !paxos_state.proposer.got_majority) {
        uint8_t lost_proposal = 0, update_phase = 0;    
        if(paxos_state.proposer.loser_timeout > 0){
          paxos_state.proposer.loser_timeout--;
          if(paxos_state.proposer.loser_timeout == 0) {
            update_phase = 1;
          }
        } else {
          if (payload->ballot.n == paxos_state.proposer.proposed_ballot.n) { //my ballot

            if (payload->phase == paxos_state.proposer.phase) {
              if(paxos_state.proposer.phase == PAXOS_PREPARE) {
                //since we do the acceptor logic first, we have the highest received accepted proposal and the corresponding value. We use them here.
                //update proposed value if there is one
                if(paxos_state.rx_accepted_proposal.n > 0){
                  paxos_state.proposer.proposed_value = paxos_state.rx_accepted_value;
                }
                if(paxos_state.rx_accepted_proposal.n > paxos_state.proposer.proposed_ballot.n){ //this shall not happen since we received our ballot
                  lost_proposal = 1;
                }
              } else if (paxos_state.proposer.phase == PAXOS_ACCEPT) {
  //              if(paxos_state.rx_min_proposal.n > paxos_state.proposer.proposed_ballot.n){
  //                lost_proposal = 1;
  //              }
              }

              //update flags
              //merge flags and do tx decision based on flags
              tx = 0;
              uint16_t n_replies = 0;
              int i;
              for( i = 0; i < FLAGS_LEN; i++){
                COOJA_DEBUG_STR("f");
                tx |= (payload->flags[i] != tx_paxos->flags[i]);
                tx_paxos->flags[i] |= payload->flags[i];
                n_replies += bit_count(tx_paxos->flags[i]);
              }
              rx_delta = tx;

              //if majority => switch to next phase
              if(!lost_proposal && n_replies > chaos_node_count/2 + chaos_node_count % 2) {
                if(paxos_state.proposer.phase == PAXOS_PREPARE){
                  paxos_state.proposer.phase = PAXOS_ACCEPT;
                  update_phase  = 1;
                } else if(paxos_state.proposer.phase == PAXOS_ACCEPT){
                  if(!paxos_state.proposer.got_majority){
                    paxos_state.proposer.got_majority = 1;
                    paxos_state.proposer.got_majority_at_slot = slot_count;
                  }
                }
              }

              /* we lose only before getting a majority to accept */
              if( paxos_state.proposer.phase == PAXOS_ACCEPT
                  && paxos_state.rx_min_proposal.n > paxos_state.proposer.proposed_ballot.n
                  && !paxos_state.proposer.got_majority) {
                lost_proposal = 1;
              }

            } else {
              rx_delta = 1; //received an old phase of our ballot ==> transmit new info

              if (payload->phase > paxos_state.proposer.phase) { //received an old phase of our ballot ==> transmit new info
                //received an advanced phase of our ballot ==> something is wrong. transmit new info
                //XXX error
                COOJA_DEBUG_STR("PROPOSER rcvd AN ADVANCED PHASE!!");
              }
            }

            //proposer looses only in prepare phase before getting majority
          } else if(payload->ballot.n > paxos_state.proposer.proposed_ballot.n
              /* && paxos_state.proposer.phase == PAXOS_ACCEPT we need to be able to exit prepare phase when we know we cannot get majority */
              && !paxos_state.proposer.got_majority) {
            lost_proposal = 1;
          } else {
            rx_delta = 1; //received a smaller ballot ==> transmit new info
          }
        }
        //if I learned about a higher ballot (when I acted as an acceptor), then I know I lost
        //but we can loose only if we have not completed yet
        if(lost_proposal /*&& !paxos_state.proposer.got_majority*/) {
          // backoff then retry with a higher ballot
          //TODO if we lose, backoff before competing with a higher ballot
          paxos_state.proposer.proposed_ballot.round++;
          if(paxos_state.rx_accepted_proposal.n > 0){
            paxos_state.proposer.proposed_value = paxos_state.rx_accepted_value;
          }
          paxos_state.proposer.phase = PAXOS_PREPARE;
          paxos_state.proposer.got_majority = 0;
          //paxos_state.acceptor.min_proposal.n = paxos_state.proposer.proposed_ballot.n;
          /* timeout before updating phase and starting a new proposal */
          paxos_state.proposer.loser_timeout =  chaos_random_generator_fast() % (20 - 5) + 5;
        }

        if(update_phase){
          tx_paxos->ballot.n = paxos_state.proposer.proposed_ballot.n;
          tx_paxos->phase = paxos_state.proposer.phase;
          tx_paxos->proposal.n = 0;
          tx_paxos->value = paxos_state.proposer.proposed_value; //does not matter if proposal_ballot = 0 ( which is an invalid ballot for our implementation that signals that nobody has accepted any proposal yet)
          /* reset flags and set my flag only */
          memcpy(tx_paxos->flags, paxos_local.paxos.flags, FLAGS_LEN);
        }
      } // end of proposer logic
    } // end of not PAXOS_INIT phase
  } // end of chaos RX and correct received packet

  /* decide next CHAOS state */
  chaos_state_t next_state = CHAOS_RX;
  if( IS_INITIATOR() && current_state == CHAOS_INIT ){
    next_state = CHAOS_TX; //for the first tx of the initiator: no increase of tx_count here
    got_valid_rx = 1; //to enable retransmissions
  } else if(current_state == CHAOS_RX && chaos_txrx_success){
    invalid_rx_count = 0;
    if( tx ){
      /* if we have not received a delta, then we limit tx rate */
      next_state = CHAOS_TX;
      if( complete ){
        if(rx_delta){
          tx_count_complete = 0;
        } else {
          tx_count_complete++;
        }
      }
    }
  } else if(current_state == CHAOS_RX && !chaos_txrx_success && got_valid_rx){
    invalid_rx_count++;
    if(invalid_rx_count > restart_threshold){
      next_state = CHAOS_TX;
      invalid_rx_count = 0;
      if( complete ){
        tx_count_complete++;
      }
      restart_threshold = chaos_random_generator_fast() % (CHAOS_RESTART_MAX - CHAOS_RESTART_MIN) + CHAOS_RESTART_MIN;
    }
  } else if(current_state == CHAOS_TX && !chaos_txrx_success){ /* we missed tx go time. Retry */
    got_valid_rx = 1; //????? check me!
    next_state = CHAOS_TX;
  } else if(current_state == CHAOS_TX && tx_count_complete > N_TX_COMPLETE){
    next_state = CHAOS_OFF;
    LEDS_OFF(LEDS_GREEN);
  }

  /* for reporting the final result */
  if(complete || slot_count >= PAXOS_ROUND_MAX_SLOTS - 1) {
    paxos_flags = tx_paxos->flags;
    paxos_local.paxos.value = paxos_state.acceptor.accepted_value;
    paxos_local.paxos.proposal.n = paxos_state.acceptor.accepted_proposal.n;
    paxos_local.paxos.ballot.n = paxos_state.acceptor.min_proposal.n;
    paxos_local.paxos.phase = tx_paxos->phase;
    if (!paxos_state.proposer.is_proposer){
      paxos_state.proposer.phase = tx_paxos->phase;
    }
  }

  /* reporting progress */
  *app_flags = payload->flags;

  int end = (slot_count >= PAXOS_ROUND_MAX_SLOTS - 2) || (next_state == CHAOS_OFF);
  if(end){
    off_slot = slot_count;
  }
  return next_state;
}

int paxos_get_flags_length() {
  return FLAGS_LEN;
}

int paxos_is_pending(const uint16_t round_count){
  return 1;
}

uint16_t paxos_get_off_slot(){
  return off_slot;
}

const paxos_t* const paxos_get_local(){
  return &paxos_local;
}

const paxos_state_t* const paxos_get_state(){
  return &paxos_state;
}

int paxos_round_begin(const uint16_t round_number, const uint8_t app_id, uint8_t is_proposer, paxos_value_t* paxos_value, uint8_t** final_flags)
{
  off_slot = PAXOS_ROUND_MAX_SLOTS;
  tx = 0;
  got_valid_rx = 0;
  complete = 0;
  completion_slot = 0;
  tx_count_complete = 0;
  invalid_rx_count = 0;

  /* init random restart threshold */
  restart_threshold = chaos_random_generator_fast() % (CHAOS_RESTART_MAX - CHAOS_RESTART_MIN) + CHAOS_RESTART_MIN;

  /* reset transaction state to start a new one */
  memset(&paxos_state, 0, sizeof(paxos_state));
  memset(&paxos_local, 0, sizeof(paxos_local));

  if( is_proposer ) {
    paxos_state.proposer.phase = PAXOS_INIT;
    paxos_state.proposer.proposed_ballot.id = chaos_node_index;
    paxos_state.proposer.proposed_ballot.round = 1; /* note that we start with 1 */
    paxos_state.proposer.proposed_value = *paxos_value; 
    paxos_state.proposer.is_proposer = 1;
    //save the value in paxos_local for now. It might not be needed though
    paxos_local.paxos.value = *paxos_value;     
  }
  /* set my flag */
  unsigned int array_index = chaos_node_index / 8;
  unsigned int array_offset = chaos_node_index % 8;
  paxos_local.paxos.flags[array_index] |= 1 << (array_offset);

  chaos_round(round_number, app_id, (const uint8_t const*)&paxos_local.paxos, sizeof(paxos_t) + paxos_get_flags_length(), PAXOS_SLOT_LEN_DCO, PAXOS_ROUND_MAX_SLOTS, paxos_get_flags_length(), process);

  memcpy(paxos_local.paxos.flags, paxos_flags, paxos_get_flags_length());
  *paxos_value = paxos_local.paxos.value;
  *final_flags = paxos_local.flags;
  return completion_slot;
}
