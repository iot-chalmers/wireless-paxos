------------------------------------------------------------------------------------------------------------------------------------------------------
RX/TX fields
	ballot
	phase = INIT
	value
	proposal: minProposal or acceptedProposal = 0

MEMORY
	Acceptor
		min_proposal (highest proposal prepared so far)
		accepted_proposal = 0 (if the node received an accept message with a ballot higher than minProposal, this value is the ballot received in the accept message)
		accepted_value = 0 (if the node received an accept message with a ballot higher than minProposal, this value is the value of the message)
	Proposer
		proposed_ballot
		proposed_value
		proposer_phase
		is_proposer (boolean, is this node a proposer)
		proposer_got_majority (boolean, states if the proposer got a majority at this phase)
	Additional
		RX_ballot (highest ballot received so far)
		RX_accepted_value
		RX_accepted_proposal (highest accepted proposal received so far)
		RX_min_proposal
		RX_phase

------------------------------------------------------------------------------------------------------------------------------------------------------

Assumptions:

1. Every node receives the broadcast primitive (including Proposers)
	From 1, a. A Proposer can learn about a message with a ballot n_i > its own ballot n
		From 1.a, b. Upon reception of a packet with n_i > n, the Proposer competes directly

2. Every node receives the answer to the broadcast primitive from every other node (including Proposers)
	Optimization: A node locally keep the RX packet information with the highest ballot N
	a. Upon reception of a message with n < N, the message is discarded and the message in memory is retransmitted

3. Every Proposer is an Acceptor
	Relaxing this assumption needs rethinking how we count a majority
	Implementation: A Proposer acts as an Acceptor first, then as a Proposer within the same computation slot

4. A ballot cannot be 0.0 (round should start at 1)
	Due to the implementation

------------------------------------------------------------------------------------------------------------------------------------------------------

If rx.phase is INIT

	If the node is a Proposer
		If the node is stately in phase INIT
			set the state phase to PREPARE
			set the tx.ballot to the state.proposed_ballot
			set the tx.phase to PREPARE
			set the state.min_proposal to the state.proposed_ballot
		EndIf
		tx = 1, we should always transmit when the phase is init
	Else // Not a Proposer
		we copy the received message into the TX message and merge the flags
	EndIf
	rx_delta = tx

Else

	// We start with the acceptor logic
	If the rx.ballot is higher or equal to the latest tx.ballot AND the rx.phase is higher or equal to the latest tx.phase
		we copy the rx packet in the tx packet

		If the rx.phase is PREPARE
			// Basic Paxos part 
			If the rx.ballot is strictly higher than the last received
				set the loca.min_proposal to the rx.ballot
			EndIf
			// Merging and max part
			If the rx.proposal is strictly lower than the state.rx_accepted_proposal
				// We now the highest value, we write it
				set tx.proposal to the state.rx_accepted_proposal
				set tx.value to the state.rx_accepted_value
			Else // Higher proposal in the packet, we should remember it
				set state.rx_accepted_proposal to the tx.proposal
				set state.rx_accepted_value to the tx.value
			EndIf
		Else If rx.phase is ACCEPT
			// Basic Paxos part
			If rx.ballot is higher or equal to the state.min_proposal
				// We accept the value
				set state.accepted_value to rx.value
				set state.accepted_proposal to rx.ballot
				set state.min_proposal to rx.ballot
			EndIf
			// Merging and max part
			set state.rx_min_proposal to MAX(state.rx_min_proposal, state.min_proposal)
			set state.rx_min_proposal to MAX(state.rx_min_proposal, rx.proposal)
			// writing the max
			If tx.proposal is different from state.rx_min_proposal
				set tx.proposal to state.rx_min_proposal
				tx = 1 // new changes, we should retransmit
			EndIf
			// Merging
			If state.accepted_proposal is strictly higher than state.rx_accept_proposal
				set state.rx_accepted_proposal to state.accepted_proposal
				set state.rx_accepted_value to state.accepted_value
			EndIf
		Else
			// Another state? this should not happen
			//ERROR
		EndIf

		do flags logic
		round is considered as complete if everybody put its flag during the ACCEPT phase

	Else
		// the received packet is somewhat an older one
		// we discard it and send the most up to date heard information
		rx_delta = 1
	EndIf

	// Proposer logic
	If state.is_proposer
		set lost_proposal to 0
		set update_phase to 0

		If rx.ballot is equal to state.proposed_ballot // This is my ballot

			If rx.phase is equal to state.proposer_phase

				If state.proposer is in phase PREPARE

					// Basic Paxos logic

					// Assumption: since we did the acceptor logic before the proposer logic, we can read locally the highest value and highest proposal
					// If we change from Proposer is an Acceptor to separate entities, we should read from the packet directly (same value)
					// ASSUMPTION: a ballot is ALWAYS higher than 0.0, round should ALWAYS start at 1!!!

					If state.rx_accepted_proposal (same as rx.proposal) is stricly higher than 0
						set state.proposed_value to state.rx_proposed_value (same as rx.value) // If at least one value was proposed, we should adopt it as our value to be accepted (in order to make the network converge)
					EndIf

					If rx_accepted_proposal is strictly higher than state.proposed_ballot
						// Optimization consequence: This should never happen because we receive back our packet if and only if it is the highest ballot in the network
						set lost_proposal to 1 // Someone got accepted before us at least 1
					EndIf

				Else If state.proposer is in phase ACCEPT

					// Basic Paxos Logic

					If state.rx_min_proposal (same as rx.proposal) is strictly higher than state.proposed_ballot
						// we know we lost
						set lost_proposal to 1
					EndIf

				EndIf

				do flags logic

				// Basic Paxos logic

				If we got majority of replies (>N/2+1)
					If state.phase is PREPARE
						set state.phase to ACCEPT
						set update_phase to 1
					Else If state.phase is ACCEPT
						If state.proposer_got_majority is not 1
							set state.proposer_got_majority to 1
							set state.proposer_got_majority_at_slot to slot_count
						EndIf
					EndIf
				EndIf

			Else

				// received an old phase of our own ballot
				set rx_delta to 1 // transmit the new info

			EndIf

		// Assumption: a Proposer can receive message 
		// Optimization: if we ehar a higher ballot, we know we have high chances of loosing

		Else If rx.ballot is stricly higher than state.proposed_ballot

			set lost_proposal to 1

		Else
			// lower ballot
			set rx_delta to 1 // We transmit our packet instead
		EndIf

		// Optimization correction: We lost only if we did not win yet
		If lost_proposal AND not state.proposer_got_majority
			increment state.proposed_ballot.round
			// Optimization: We can already write which value we should use later, because we know it
			set state.proposed_value to state.rx_accepted_value
			set state.proposer_phase to PREPARE
			set state.proposer_got_majority to 0 // should be the vase already
			set state.min_proposal to state.proposed_ballot // we should have the highest proposal so far
			set update_phase to 1
		EndIf

		// we are changing phase (from prepare to accept or we lost)
		If update_phase
			set tx.ballot tostate.proposed_ballot
			set tx.phase to state.proposer_phase
			// Assumption: the ballot number should always be strictly higher than 0!!!, we use the 0 as comparison
			set tx.proposal to 0
			set tx.value to state.proposed_value
			// IMPORTANT!!! THE FLAGS SHOULD BE RESETTED
			reset the flags
		EndIf

	EndIf

EndIf











